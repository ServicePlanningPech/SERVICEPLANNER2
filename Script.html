<script>
// Global variables
let songListData = [];
let activeRow = null;
let selectedSong = null;
let currentServiceOrder = null;
let selectedPlanId = null;
let isInitialized = false;
let logMsgNum = 0;
let isContextMenuVisible = false; 
let currentJsonFileId = null;
let isSaving = false;
let saveTimeout = 0;
let songsLoaded = false;
let currentUploadType = null;
let settingsId = null;
let settings = null;
// Global variables for slides gallery
let currentZoomLevel = 2; // Default zoom level (1-3)
let isNameSearch = true;

/* --------------------------------------------------------------------------------------------------- */
/* - Here's where it all starts                                                                      - */
/* --------------------------------------------------------------------------------------------------- */
//document.addEventListener('DOMContentLoaded', function() { 
window.onload = async function() {  
  showToast("Initializing Service Planner.....",5);
  getSettings();
  updateStorageInfo();
  adjustTableForMobile(); 
  loadServicePlans(); 
  initializeEventListeners(); 
  loadSongs(); 
  initializeModalAccessibility();
  initializeServiceNotes(); 
  initializeActionButtons();
//});
};

function debugLog(message) {
 if (settings && settings.Debug === "on") {
  logMsgNum++;
  const prefix = "CLIENT MESSAGE: "+ logMsgNum;
  console.log(`**${prefix}: ${message}`);
  google.script.run
      .withFailureHandler(error => console.error(`**${prefix} ERROR: Failed to log to spreadsheet:`, error))
      .debugLog(`${prefix}: ${message}`);
  }
}

function logWithTimestamp(message) { 
  const timestamp = new Date().toISOString(); 
  console.log(`[${timestamp}] ${message}`); 
}

function showToast(message,duration) { 
  var toast = document.getElementById("toast"); 
  toast.textContent = message; 
  toast.className = "show"; 
  setTimeout(function() { toast.className = toast.className.replace("show", ""); }, duration*1000);
}

function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
         || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
}

function adjustTableForMobile() {
  if (isMobileDevice()) {
    document.body.classList.add('mobile-device');
    debugLog("RUNNING ON MOBILE");
    
    // Adjust table column widths for mobile
    const table = document.getElementById('serviceItemsTable');
    if (table) {
      const headerRow = table.querySelector('thead tr');
      if (headerRow) {
        headerRow.children[0].width = "8%";  // # column
        headerRow.children[1].width = "20%"; // Item Type
        headerRow.children[2].width = "52%"; // Item Detail
      }
    }
  }
}

function handleError(error) {
  console.error("**SPA ERROR: ", error);
  debugLog("ERROR: " + error.message);
  alert('An error occurred: ' + error.message);
}


// Navigation functions
function showSection(sectionId) {
  document.querySelectorAll('.app-section').forEach(section => {
    section.classList.remove('active');
  });
  document.getElementById(sectionId).classList.add('active');
}



function initializeAll() {
  if (isInitialized) return;
  
  initializeServiceItemsTable();
  setupContextMenu();
  updateContextMenu(); 
  setupUploadHandlers();
  setupSongSelectionHandlers();
  setupItemTypeHandlers();
  
  isInitialized = true;
}

function initializeModalAccessibility() {
  // Get all modals
  const modals = document.querySelectorAll('.modal');
  
  modals.forEach(modal => {
    // Store the element that triggered the modal
    let lastFocusedElement = null;
    
    // Before modal shows
    modal.addEventListener('show.bs.modal', function() {
      lastFocusedElement = document.activeElement;
    
    });
    
    // After modal is shown
    modal.addEventListener('shown.bs.modal', function() {
      // Find the first focusable element in the modal
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (focusableElements.length > 0) {
        focusableElements[0].focus();
      }
    });
    
    // After modal is hidden
    modal.addEventListener('hidden.bs.modal', function() {
      // Restore focus to the triggering element
      if (lastFocusedElement) {
        lastFocusedElement.focus();
      }
    });
    
    // Handle keyboard navigation
    modal.addEventListener('keydown', function(e) {
      if (e.key === 'Tab') {
        const focusableElements = modal.querySelectorAll(
          'button:not([disabled]), [href]:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"]):not([disabled])'
        );
        
        const firstFocusable = focusableElements[0];
        const lastFocusable = focusableElements[focusableElements.length - 1];
        
        // If shift + tab and first element is focused, move to last
        if (e.shiftKey && document.activeElement === firstFocusable) {
          e.preventDefault();
          lastFocusable.focus();
        }
        // If tab and last element is focused, move to first
        else if (!e.shiftKey && document.activeElement === lastFocusable) {
          e.preventDefault();
          firstFocusable.focus();
        }
      }
      // Close modal on Escape
      else if (e.key === 'Escape') {
        const bsModal = bootstrap.Modal.getInstance(modal);
        if (bsModal) {
          bsModal.hide();
        }
      }
    });
  });
}

function showModal(modalId) {
  const modal = document.getElementById(modalId);
  if (!modal) return;
  
  const bsModal = new bootstrap.Modal(modal, {
    backdrop: 'static', // Prevents closing on clicking outside
    keyboard: true      // Allows ESC key to close
  });
  
  bsModal.show();
}


async function loadCurrentServiceOrder(folderId) {
  debugLog("Loading service order for folder: " + folderId);
  showLoading(true, 'Loading service plan...');

  try {
    const serviceOrder = await loadServiceOrder(folderId);
    
    if (serviceOrder) {
      currentServiceOrder = serviceOrder;
      currentJsonFileId = serviceOrder.jsonFileId; 
      document.getElementById('planTitle').textContent = 
        'Service Plan for ' + serviceOrder.date + ' - ' + serviceOrder.type;
      
      initializeAll();
      populateServiceItems(serviceOrder.orderOfService);
      
      // Set the service notes
      const notesArea = document.getElementById('serviceNotes');
      if (notesArea) {
        notesArea.innerHTML = serviceOrder.comments || '';
      }

      // Set additional emails
      const emailsArea = document.getElementById('additionalEmails');
      if (emailsArea) {
        emailsArea.value = serviceOrder.extraEmails || '';
      }
   
    } else {
      debugLog("No existing service order found - new plan");
      initializeAll();
    }
  } catch (error) {
    debugLog("Error loading service order: " + error.message);
    alert('Error loading service order: ' + error.message);
  } finally {
    showLoading(false);
  }
}

function initializeEventListeners() {
  //debugLog("Initializing event listeners");
  
  // Plan list event listeners
  document.getElementById('planListBody').addEventListener('click', handlePlanSelection);
  document.getElementById('planListBody').addEventListener('dblclick', handlePlanDoubleClick);
  document.getElementById('newPlanBtn').addEventListener('click', showNewPlanModal);
  document.getElementById('editPlanBtn').addEventListener('click', handleEditPlan);
  document.getElementById('deletePlanBtn').addEventListener('click', showDeleteConfirmation);
  document.getElementById('refreshGalleryBtn').addEventListener('click', refreshGallery);
  document.getElementById('createPlanBtn').addEventListener('click', newPlan);
  document.getElementById('howToPlanListBtn').addEventListener('click', showHowTo);
  document.getElementById('howToServiceBtn').addEventListener('click', showHowTo);
  
  // Add change event listener for checkboxes
  document.addEventListener('change', function(e) {
    if (e.target.matches('.slide-before-checkbox, .slide-after-checkbox')) {
      triggerAutoSave();
      refreshGallery(); // Refresh gallery when checkboxes change
    }
});

 
  // Plan edit event listeners
  document.getElementById('backToPlansBtn').addEventListener('click', async () => {
  // Save the service plan first
  if (currentJsonFileId) {
    showToast("Saving service plan...", 3);
    await saveServiceOrder();
  }

  // Reset selection state
  selectedPlanId = null;
  
  // Reset any selected rows
  document.querySelectorAll('#planListBody tr').forEach(tr => {
    tr.classList.remove('selected');
  });
  
  // Disable action buttons
  document.getElementById('editPlanBtn').disabled = true;
  document.getElementById('deletePlanBtn').disabled = true;
  
  // Switch to plans list view and refresh
  showSection('plansList');
  loadServicePlans();
});
};

function handlePlanSelection(e) {
  const row = e.target.closest('tr');
  if (!row || !row.classList.contains('plan-row')) return;

  // Get the clicked element
  const clickedElement = e.target;
  
  // Only proceed if we clicked the row or one of its td elements
  if (!clickedElement.matches('tr.plan-row, tr.plan-row td')) return;

  document.querySelectorAll('#planListBody tr').forEach(tr => {
    tr.classList.remove('selected');
  });

  row.classList.add('selected');
  selectedPlanId = row.dataset.id;

  // Enable the action buttons
  document.getElementById('editPlanBtn').disabled = false;
  document.getElementById('deletePlanBtn').disabled = false;
}

function handlePlanDoubleClick(e) {
  const row = e.target.closest('tr');
  if (!row) return;

  selectedPlanId = row.dataset.id;
  handleEditPlan();
}

function handleEditPlan() {
  if (!selectedPlanId) return;
  showLoading(true);
  loadCurrentServiceOrder(selectedPlanId);
  showSection('planEdit');
}

// Update the displayPlans function in Script.html
function displayPlans(plans) {
  const tbody = document.getElementById('planListBody');
  
  if (!tbody) {
    debugLog("ERROR: planListBody element not found");
    return;
  }
  
  tbody.innerHTML = plans.map(plan => {
    const lastModified = plan.lastModified ? new Date(plan.lastModified) : null;
    const formattedLastModified = lastModified ? 
      lastModified.toLocaleDateString() + ' ' + lastModified.toLocaleTimeString('en-US', {
        hour: '2-digit',
        minute: '2-digit'
      }) : 'N/A';
    
    // Calculate day of week
    const [day, month, year] = plan.date.split('-');
    const date = new Date(year, month - 1, day);
    const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
    
    return `
      <tr class="plan-row" data-id="${plan.id}">
        <td>${dayName}</td>
        <td>${formatDisplayDate(plan.date)}</td>
        <td>${plan.type}</td>
        <td>${formattedLastModified}</td>
        <td>${plan.status}</td>   
      </tr>
    `;
  }).join('');
}

function formatDisplayDate(dateStr) {
  const [day, month, year] = dateStr.split('-');
  return `${day} ${getMonthName(month)} ${year}`;
}

function getMonthName(month) {
  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  return months[parseInt(month) - 1];
}

function showNewPlanModal() {
  // Get and clear the form elements
  const dateInput = document.getElementById('planDate');
  const typeSelect = document.getElementById('planType');
  const otherTypeInput = document.getElementById('otherType');
  const otherTypeDiv = document.getElementById('otherTypeDiv');
  
  // Reset form
  dateInput.value = '';
  typeSelect.value = 'Morning';
  otherTypeInput.value = '';
  otherTypeDiv.classList.add('d-none');
  
  // Add change handler for plan type
  typeSelect.addEventListener('change', function() {
    if (this.value === 'Other') {
      otherTypeDiv.classList.remove('d-none');
      otherTypeInput.focus();
    } else {
      otherTypeDiv.classList.add('d-none');
    }
  });

  const modal = new bootstrap.Modal(document.getElementById('newPlanModal'));
  modal.show();
}

function showConfirmModal(options) {
  const {
    title = 'Confirm',
    message = 'Are you sure?',
    buttonText = 'Confirm',
    buttonClass = 'btn-primary',
    onConfirm = () => {}
  } = options;

  const modal = document.getElementById('confirmModal');
  const confirmBtn = document.getElementById('confirmModalBtn');
  
  // Set modal content
  document.getElementById('confirmModalTitle').textContent = title;
  document.getElementById('confirmModalBody').textContent = message;
  confirmBtn.textContent = buttonText;
  
  // Update button class
  confirmBtn.className = `btn ${buttonClass}`;
  
  // Remove existing event listeners
  const newConfirmBtn = confirmBtn.cloneNode(true);
  confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
  
  // Add new event listener
  newConfirmBtn.addEventListener('click', async () => {
    try {
      await onConfirm();
      const modalInstance = bootstrap.Modal.getInstance(modal);
      modalInstance.hide();
    } catch (error) {
      console.error('Error in confirmation handler:', error);
      alert('An error occurred: ' + error.message);
    }
  });
  
  // Show modal
  const modalInstance = new bootstrap.Modal(modal);
  modalInstance.show();
}

function showDeleteConfirmation() {
  if (!selectedPlanId) return;
  
  showConfirmModal({
    title: 'Confirm Deletion',
    message: 'Are you sure you want to delete this service plan?',
    buttonText: 'Delete',
    buttonClass: 'btn-danger',
    onConfirm: async () => {
      await deleteThisPlan();
    }
  });
}

async function newPlan() {
  const date = document.getElementById('planDate').value;
  let type = document.getElementById('planType').value;
  if (type === 'Other') {
    type = document.getElementById('otherType').value;
  }
  if (!date || !type) {
    alert('Please fill in all fields');
    return;
  }
  
  showLoading(true, 'Creating new plan...');
  const formattedDate = formatDate(date);
  await createNewPlan(formattedDate, type)
    .then(result => {
      selectedPlanId = result.folderId;
      const modal = bootstrap.Modal.getInstance(document.getElementById('newPlanModal'));
      modal.hide();
      loadCurrentServiceOrder(selectedPlanId);
      showSection('planEdit');
    })
    .catch(error => {
        alert('Error:' + error);
    }); 
}

function formatDate(dateString) {
  const date = new Date(dateString);
  return date.getDate().toString().padStart(2, '0') + '-' +
         (date.getMonth() + 1).toString().padStart(2, '0') + '-' +
         date.getFullYear();
}

async function deleteThisPlan() {
  if (!selectedPlanId) return;
  
  showLoading(true, 'Deleting plan...');
  await deletePlan(selectedPlanId)
    .then(result => {
  //    const modal = bootstrap.Modal.getInstance(document.getElementById('deleteModal'));
  //    modal.hide();
      selectedPlanId = null;
      document.getElementById('editPlanBtn').disabled = true;
      document.getElementById('deletePlanBtn').disabled = true;
      loadServicePlans();
      })
    .catch(error => {
        alert('Error:' + error);
       }); 
}

async function saveServiceOrder() {
  if (isSaving) {
    return;
  }
  isSaving = true;

  const startTime = new Date().getTime();
  if (!currentJsonFileId) {   
    debugLog("ERROR: No JSON file ID available");
    return;
  }

  const rows = document.querySelectorAll('#serviceItemsTable tbody tr');
  const items = Array.from(rows)
    .map(row => {
      const type = row.querySelector('.item-type').textContent.trim();
      const typeCell = row.querySelector('.item-type');
      const detailCell = row.querySelector('.item-detail');
      const detail = detailCell.textContent.trim();
      const slides = row.querySelector('.item-slides').textContent.trim();
      const beforeCheckbox = row.querySelector('.slide-before-checkbox');
      const afterCheckbox = row.querySelector('.slide-after-checkbox');
      const turlsCell = row.querySelector('.item-tUrls');
      
      let tUrls = [];
      if (turlsCell && turlsCell.textContent) {
        try {
          tUrls = JSON.parse(turlsCell.textContent);
        } catch (e) {
          debugLog(`Error parsing tUrls for row: ${e}`);
        }
      }
      
      const item = {
        type: type,
        detail: detail,
        link: typeCell.dataset.id || '',
        slides: slides,
        blankBefore: beforeCheckbox.checked,
        blankAfter: afterCheckbox.checked,
        tUrls: tUrls
      };
      
      return item;
    })
    .filter((item) => {
      const hasContent = item.type !== '' || item.detail !== '';
      return hasContent;
    });

  const serviceNotes = document.getElementById('serviceNotes').innerHTML.trim();
  const additionalEmails = document.getElementById('additionalEmails').value.trim();

//HERE
  const serviceOrder = {
    orderOfService: items,
    comments: serviceNotes,
    extraEmails: additionalEmails,
    status: currentServiceOrder ? currentServiceOrder.status : 'Draft'
  };
  
  await saveOrder(currentJsonFileId, serviceOrder)
    .then(result => {
      const endTime = new Date().getTime();
      const saveTime = endTime - startTime;
    })
    .catch(error => {
      alert('Error:' + error);
    }); 
    
  isSaving = false;
}

function initializeServiceItemsTable() {
  //debugLog("Initializing service items table");
  const tbody = document.querySelector('#serviceItemsTable tbody');
  tbody.innerHTML = '';

  // Create initial 12 rows
  for (let i = 1; i <= 12; i++) {
    const row = document.createElement('tr');
    row.className = i % 2 === 0 ? 'table-light' : '';
    row.innerHTML = `
          <td class="item-number grab-icon" draggable="true">${i}</td>
          <td class="item-type" contenteditable="true"></td>
          <td class="item-detail" contenteditable="true"></td>
          <td>
              <input type="checkbox" class="slide-before-checkbox" title="Add blank slide before">
          </td>
          <td>
              <input type="checkbox" class="slide-after-checkbox" title="Add blank slide after">
          </td>
          <td class="item-slides"></td>
          <td class="item-tUrls"></td>
          <td>
            <button class="btn btn-sm upload-btn">
              <span>⬆️</span>
            </button>
          </td>
          <td>
            <button class="btn btn-sm delete-btn">
                <span>🗑</span>
            </button>
          </td>
          <td>
            <button class="btn btn-sm edit-btn">
              <span>✏️</span>
            </button>
          </td>
      `;
    tbody.appendChild(row);
  }

  // Initialize all upload buttons as disabled
    initializeUploadButtons();
    initializeEditButtons();
    setupEditHandlers();

  // Add click handler for item type
  tbody.addEventListener('click', function(e) {
    const typeCell = e.target.closest('.item-type');
    if (typeCell && typeCell.classList.contains('song-link')) {
      showPreview(typeCell.dataset.id, typeCell.textContent);
    }
  });

  // Add input handler for item type cells
  tbody.addEventListener('input', function(e) {
    const typeCell = e.target.closest('.item-type');
    if (typeCell) {
      const row = typeCell.closest('tr');
      if (typeCell.textContent.trim()) {
        enableUploadButton(row);
      } else {
        disableUploadButton(row);
      }
    }
  });

  initializeDragAndDrop();
  setupDeleteHandlers();
}

function updateContextMenu() {
  const menu = document.getElementById('itemTypeMenu');
  if (!menu) return;

  // Keep only the NewLine item
  menu.innerHTML = '<button class="dropdown-item" data-type="NewLine">New Line</button>';

  // Check if we have custom menu items in settings
  if (settings && settings.ContextMenu) {
    const menuItems = settings.ContextMenu.split(',').map(item => item.trim());
    
    menuItems.forEach(item => {
      const button = document.createElement('button');
      button.className = 'dropdown-item';
      button.dataset.type = item;
      button.textContent = item;
      menu.appendChild(button);
    });
  } else {
    // Default items if no settings found
    const defaultItems = ['Welcome', 'Notices', 'Sing', 'Creed', 'Reading', 'Prayer', 'Sermon', 'Message', 'Communion'];
    defaultItems.forEach(item => {
      const button = document.createElement('button');
      button.className = 'dropdown-item';
      button.dataset.type = item;
      button.textContent = item;
      menu.appendChild(button);
    });
  }
}

// Modified setupContextMenu function
function setupContextMenu() {
  const menu = document.getElementById('itemTypeMenu');
  
  if (!menu.hasAttribute('data-initialized')) {
    // Update menu items
    updateContextMenu();
    
    // Add double-click handler
    document.addEventListener('dblclick', function(e) {
      const cell = e.target.closest('.item-type');
      if (cell) {
        showContextMenu(e, cell);
      }
    });

    document.addEventListener('contextmenu', function(e) {
      const cell = e.target.closest('.item-type');
      if (cell) {
        e.preventDefault();
        showContextMenu(e, cell);
      }
    });

    menu.addEventListener('click', function(e) {
      if (e.target.classList.contains('dropdown-item')) {
        e.preventDefault();
        const selectedType = e.target.dataset.type;
        const activeCell = document.querySelector('.item-type.active');
        
        if (activeCell) {
          const row = activeCell.closest('tr');
          if (selectedType === 'NewLine') {
            insertNewLine(row);
          } else {
            activeCell.textContent = selectedType;
            enableUploadButton(row);
            
            // Trigger song selection for Song/Creed
            if (['Song', 'Sing', 'Hymn', 'Creed'].includes(selectedType)) {
              activeRow = activeCell.closest('tr');
              if (songsLoaded) {
                displaySongModal();
              } else {
                showToast("Song database is still loading, try again in a few seconds", 5);
              }
            }
          }

          activeCell.classList.remove('active');
          triggerAutoSave();
        }
        
        hideContextMenu();
      }
    });

    document.addEventListener('click', function(e) {
      if (!e.target.closest('#itemTypeMenu') && isContextMenuVisible) {
        hideContextMenu();
      }
    });

    menu.setAttribute('data-initialized', 'true');
  }
}

function showContextMenu(e, cell) {
  const menu = document.getElementById('itemTypeMenu');
  document.querySelectorAll('.item-type').forEach(cell => cell.classList.remove('active'));
  cell.classList.add('active');
  
  menu.style.visibility = 'hidden';
  menu.style.display = 'block';
  
  // Position vertically in middle of screen
  menu.style.top = '50%';
  menu.style.transform = 'translateY(-50%)';
  
  // Position horizontally just after the item type column
  const typeCell = cell.getBoundingClientRect();
  menu.style.left = (typeCell.right + 5) + 'px';
  
  menu.style.visibility = 'visible';
  isContextMenuVisible = true;
}

function hideContextMenu() {
  //debugLog("Hiding context menu");
  const menu = document.getElementById('itemTypeMenu');
  menu.style.display = 'none';
  document.querySelectorAll('.item-type').forEach(cell => cell.classList.remove('active'));
  isContextMenuVisible = false; 
}

function initializeDragAndDrop() {
  //debugLog("Initializing drag and drop");
  const tbody = document.querySelector('#serviceItemsTable tbody');
  let draggedRow = null;
  let startIndex = -1;
  
  tbody.addEventListener('dragstart', function(e) {
    const row = e.target.closest('tr');
    if (row) {
      draggedRow = row;
      startIndex = Array.from(tbody.children).indexOf(row);
      row.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
    }
  });

  tbody.addEventListener('dragend', function(e) {
    if (draggedRow) {
      draggedRow.classList.remove('dragging');
      draggedRow = null;
      startIndex = -1;
      reorderItemNumbers();
      reapplyAlternatingColors();
      triggerAutoSave(); 
      refreshGallery();
    }
  });

  tbody.addEventListener('dragover', function(e) {
    e.preventDefault();
    if (!draggedRow) return;

    const row = e.target.closest('tr');
    if (row && row !== draggedRow) {
      const rect = row.getBoundingClientRect();
      const midpoint = (rect.top + rect.bottom) / 2;
      if (e.clientY < midpoint) {
        row.parentNode.insertBefore(draggedRow, row);
      } else {
        row.parentNode.insertBefore(draggedRow, row.nextSibling);
      }
    }
  });
}

function setupUploadHandlers() {
  document.querySelector('#serviceItemsTable').addEventListener('click', async function(e) {
    if (e.target.closest('.upload-btn')) {
      const row = e.target.closest('tr');
      const typeCell = row.querySelector('.item-type');
      
      // Check if row already has a link
      if (typeCell.dataset.id) {
        showConfirmModal({
          title: 'Replace Existing File',
          message: 'This item already has an attached file. Do you want to replace it?',
          buttonText: 'Replace',
          buttonClass: 'btn-warning',
          onConfirm: async () => {
            // Clear existing link
            typeCell.dataset.id = '';
            typeCell.classList.remove('song-link');
            
            activeRow = row;
            showUploadTypeModal();
          }
        });
        return;
      }
      
      activeRow = row;
      showUploadTypeModal();
    }
  });

  // Set up upload type selection
  document.querySelectorAll('#uploadTypeModal .list-group-item').forEach(button => {
    button.addEventListener('click', handleUploadTypeSelection);
  });

  // Set up file upload handling
  document.getElementById('uploadFileBtn').addEventListener('click', handleFileUpload);
}

function showUploadTypeModal() {
  showModal('uploadTypeModal');
}



function handleUploadTypeSelection(e) {
  const button = e.currentTarget;
  currentUploadType = button.dataset.uploadType;
  
  // Close upload type modal
  const typeModal = bootstrap.Modal.getInstance(document.getElementById('uploadTypeModal'));
  typeModal.hide();

  if (currentUploadType === 'slidemaker') {
    // Create new presentation directly
    handleSlideMakerUpload();
  } else {
    // Show file upload modal with appropriate settings
    configureFileUploadModal();
  }
}

function configureFileUploadModal() {
  const fileInput = document.getElementById('fileInput');
  const helpText = document.getElementById('fileTypeHelp');
  const uploadStatus = document.getElementById('uploadStatus');
  
  // Clear previous input
  fileInput.value = '';
  uploadStatus.style.display = 'none';
  uploadStatus.textContent = '';
  
  // Configure based on upload type
  if (currentUploadType === 'powerpoint') {
    fileInput.accept = '.pptx';
    helpText.textContent = 'Select a PowerPoint file (PPTX)';
  } else if (currentUploadType === 'image') {
    fileInput.accept = '.jpg,.jpeg,.png';
    helpText.textContent = 'Select an image file (JPG, PNG)';
  }
  
  // Show upload modal
  const modal = new bootstrap.Modal(document.getElementById('fileUploadModal'));
  modal.show();


}

async function handleFileUpload() {
  try {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      
      
      if (!file) {
        showUploadStatus('Please select a file', 'warning');
        return;
      }

      showUploadStatus('Uploading...', 'info');
      
      // Create a new FileReader
    
      const reader = new FileReader();
      
      reader.onload = async function(e) {
        const content = e.target.result.split(',')[1]; // Get base64 content
        
        await uploadFile({content: content,mimeType: file.type,name: file.name}, 
                      file.name, selectedPlanId, currentUploadType)
            .then(result => {
              handleUploadSuccess(result);
            })
            .catch(error => {
              handleUploadError(error);
            }); 

      };
      
      reader.onerror = function(error) {
        handleUploadError(error);
      };
      
      // Read the file as base64
      reader.readAsDataURL(file);
    
  } catch (error) {
    handleUploadError(error);
  }
}
//HERE
async function handleSlideMakerUpload() {
  const itemDetail = activeRow.querySelector('.item-detail').textContent.trim();
  const name = itemDetail || 'New Presentation';
  
  try {
    // First get available templates
         await getSlideTemplates()
         .then(result => {
          templates = result;
         })
        .catch(error => {
          handleUploadError(error);
        });   
    
    // Show template selection modal if templates exist
    if (templates && templates.length > 0) {
      await showTemplateSelectionModal(templates, name);
    } else {
      // If no templates, create blank presentation
      
      await createSlidePresentation(name, selectedPlanId, null)
         .then(result => {
          handleSlideMakerResult(result);
         })
        .catch(error => {
          handleUploadError(error);
        }); 
      
    }
  } catch (error) {
    handleUploadError(error);
  }
}

function showTemplateSelectionModal(templates, presentationName) {
  return new Promise((resolve, reject) => {
    const modal = document.getElementById('templateSelectionModal');
    const listGroup = modal.querySelector('.list-group');
    
    // Save the No Template button before clearing
    const noTemplateButton = listGroup.querySelector('[data-template-id=""]');
    listGroup.innerHTML = '';
    
    // Restore the No Template button
    if (noTemplateButton) {
      listGroup.appendChild(noTemplateButton.cloneNode(true));
    }
    
    // Add template options
    templates.forEach(template => {
      const button = document.createElement('button');
      button.className = 'list-group-item list-group-item-action';
      button.dataset.templateId = template.id;
      button.innerHTML = `
        <h6 class="mb-1">${template.name}</h6>
        <small>Use this template</small>
      `;
      listGroup.appendChild(button);
    });
    
    // Handle template selection
    listGroup.addEventListener('click', async function(e) {
      const button = e.target.closest('.list-group-item');
      if (!button) return;
      
      const templateId = button.dataset.templateId;
      
      // Hide the template selection modal
      const bsModal = bootstrap.Modal.getInstance(modal);
      bsModal.hide();
      
      // Create presentation with or without template
      await createSlidePresentation(presentationName, selectedPlanId, templateId)
        .then(result => {
          handleSlideMakerResult(result);
        })
        .catch(error => {
          handleUploadError(error);
        }); 
    });
    
    // Show the modal
    const bsModal = new bootstrap.Modal(modal);
    bsModal.show();
    
    // Clean up when modal is hidden
    modal.addEventListener('hidden.bs.modal', function cleanup() {
      modal.removeEventListener('hidden.bs.modal', cleanup);
    });
  });
}

function handleSlideMakerResult(result) {
  if (result.editUrl) {
    const typeCell = activeRow.querySelector('.item-type');
    const beforeCheckbox = activeRow.querySelector('.slide-before-checkbox');
    const afterCheckbox = activeRow.querySelector('.slide-after-checkbox');
    
    // Enable and show checkboxes
    beforeCheckbox.disabled = false;
    afterCheckbox.disabled = false;
    beforeCheckbox.style.visibility = 'visible';
    afterCheckbox.style.visibility = 'visible';
    
    typeCell.dataset.id = result.fileId;
    typeCell.classList.add('song-link');

    // First attempt to open the window
    const editWindow = window.open(result.editUrl, '_blank');
    
    // Check if popup was blocked
    if (!editWindow || editWindow.closed || typeof editWindow.closed === 'undefined') {
      // Create a clickable link if popup was blocked
      const overlay = document.createElement('div');
      overlay.id = 'popupBlockedOverlay';
      overlay.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 9999;
        text-align: center;
      `;
      overlay.innerHTML = `
        <h4>Popup Blocked</h4>
        <p>Your browser blocked the slides editor window.</p>
        <p>Click the button below to open the editor:</p>
        <button class="btn btn-primary" id="openEditorBtn">Open Slides Editor</button>
      `;
      document.body.appendChild(overlay);
      
      // Add click handler for the button
      document.getElementById('openEditorBtn').onclick = function() {
        overlay.remove();
        window.open(result.editUrl, '_blank');
        setupEditingOverlay(result);
      };
      return;
    }
    
    // Set up the editing overlay
    setupEditingOverlay(result);
    
    // Set up an interval to check if the edit window is closed
    const checkWindow = setInterval(async () => {
      if (editWindow.closed) {
        clearInterval(checkWindow);
        
        // Clean up the editing state
        cleanupEditingState();
        
        // Get new thumbnails and refresh gallery
        if (activeRow) {
          const typeCell = activeRow.querySelector('.item-type');
          const slidesCell = activeRow.querySelector('.item-slides');
          const turlsCell = activeRow.querySelector('.item-tUrls');
       
          await getThumbnailUrls(result.fileId)
            .then(result => {
              thumbnailUrls = result;
            })
            .catch(error => {
              throw error(error);
            }); 
          if (thumbnailUrls) {
            slidesCell.textContent = thumbnailUrls.length;
            turlsCell.textContent = JSON.stringify(thumbnailUrls);
            refreshGallery();
            triggerAutoSave();
          }
        }
      }
    }, 1000);
  }
}

function setupEditingOverlay(result) {
    // Create a full-screen backdrop
    const backdrop = document.createElement('div');
    backdrop.id = 'editingBackdrop';
    backdrop.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.3);
      z-index: 9998;
    `;
    document.body.appendChild(backdrop);
    
    // Create an overlay with a message and manual close option
    const overlay = document.createElement('div');
    overlay.id = 'editingOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 9999;
      text-align: center;
      pointer-events: auto;
    `;
    overlay.innerHTML = `
      <h4>Editing Slides</h4>
      <p>Please complete your edits and close the slides tab to continue.</p>
      <button class="btn btn-primary" id="doneEditingBtn">I'm Done Editing</button>
    `;
    document.body.appendChild(overlay);
    
    // Add click handler for manual completion
    document.getElementById('doneEditingBtn').onclick = async function() {
      cleanupEditingState();
      
      // Update thumbnails
      if (activeRow && result.fileId) {
        await getThumbnailUrls(result.fileId)
         .then(result => {
          thumbnailUrls = result;
         })
         .catch(error => {
           throw error(error);
         }); 
          if (thumbnailUrls) {
            const slidesCell = activeRow.querySelector('.item-slides');
            const turlsCell = activeRow.querySelector('.item-tUrls');
            slidesCell.textContent = thumbnailUrls.length;
            turlsCell.textContent = JSON.stringify(thumbnailUrls);
            refreshGallery();
            triggerAutoSave();
          }
       
      }
    };
}

function cleanupEditingState() {
    // Remove the backdrop if it exists
    const backdrop = document.getElementById('editingBackdrop');
    if (backdrop) {
        backdrop.remove();
    }
    
    // Remove the overlay if it exists
    const overlay = document.getElementById('editingOverlay');
    if (overlay) {
        overlay.remove();
    }
    
    // Remove the popup blocked overlay if it exists
    const popupOverlay = document.getElementById('popupBlockedOverlay');
    if (popupOverlay) {
        popupOverlay.remove();
    }
}

async function handleUploadSuccess(result) {
  // Close modal
  const uploadModal = bootstrap.Modal.getInstance(document.getElementById('fileUploadModal'));
  if (uploadModal) {
    uploadModal.hide();
  }
        
  if (result.success) {
    const typeCell = activeRow.querySelector('.item-type');
    const slidesCell = activeRow.querySelector('.item-slides');
    const turlsCell = activeRow.querySelector('.item-tUrls');
    const beforeCheckbox = activeRow.querySelector('.slide-before-checkbox');
    const afterCheckbox = activeRow.querySelector('.slide-after-checkbox');
    beforeCheckbox.disabled = false;
    afterCheckbox.disabled = false;
    beforeCheckbox.style.visibility = 'visible';
    afterCheckbox.style.visibility = 'visible';
    beforeCheckbox.checked = true;
    typeCell.classList.add('song-link');
    typeCell.dataset.id = result.fileId;
    
    // Use thumbnails from the upload response
    if (result.thumbnailUrls) {
      slidesCell.textContent = result.thumbnailUrls.length;
      turlsCell.textContent = JSON.stringify(result.thumbnailUrls);
      refreshGallery();
      triggerAutoSave();
    }
  } else {
    showUploadStatus('Upload failed', 'danger');
  }
}

function handleUploadError(error) {
  debugLog('Upload failed: ' + error.message + 'danger');
  showUploadStatus('Upload failed: ' + error.message, 'danger');
}


// Add new function to handle item type changes
function setupItemTypeHandlers() {
  //debugLog("Setting up item type handlers");
  
  const tbody = document.querySelector('#serviceItemsTable tbody');
  
  // Handle double-click on item type
  tbody.addEventListener('dblclick', function(e) {
    const typeCell = e.target.closest('.item-type');
    if (typeCell) {
      const type = typeCell.textContent.toLowerCase();
      if (type === 'song' || type === 'sing' || type === 'hymn' || type === 'creed') {
        activeRow = typeCell.closest('tr');
        displaySongModal();
      }
    }
  });
  
  // Handle changes to item type
  tbody.addEventListener('input', function(e) {
    const typeCell = e.target.closest('.item-type');
    if (typeCell) {
      const type = typeCell.textContent.toLowerCase();
      if (type === 'song' || type === 'sing' || type === 'hymn' ||type === 'creed') {
        activeRow = typeCell.closest('tr');
        displaySongModal();
      }
    }
  });
}

function setupSongSelectionHandlers() {
  const songSearch = document.getElementById('songSearch');
  songSearch.addEventListener('input', function(e) {
    filterSongList(e.target.value);
  });

  const songSelectList = document.getElementById('songSelectList');
  songSelectList.addEventListener('click', handleSongSelection);
  songSelectList.addEventListener('dblclick', handleSongDoubleClick);

  document.getElementById('chooseSongBtn').addEventListener('click', handleSongChoice);
}

function handleSongSelection(e) {
  const songItem = e.target.closest('.list-group-item');
  if (!songItem) return;
  
  document.querySelectorAll('.list-group-item').forEach(item => {
    item.classList.remove('active');
  });
  songItem.classList.add('active');
  selectedSong = {
    name: songItem.dataset.name,
    id: songItem.dataset.id
  };
  document.getElementById('chooseSongBtn').disabled = false;
}

function handleSongDoubleClick(e) {
  const songItem = e.target.closest('.list-group-item');
  if (!songItem) return;
  
  selectedSong = {
    name: songItem.dataset.name,
    id: songItem.dataset.id
  };
  handleSongChoice();
}

async function handleSongChoice() {
  if (!activeRow || !selectedSong) return;

  try {
    const songModal = bootstrap.Modal.getInstance(document.getElementById('songSelectModal'));
    if (songModal) {
      songModal.hide();
    }
    
    const typeCell = activeRow.querySelector('.item-type');
    const detailCell = activeRow.querySelector('.item-detail');
    const slidesCell = activeRow.querySelector('.item-slides');
    const turlsCell = activeRow.querySelector('.item-tUrls');
    const beforeCheckbox = activeRow.querySelector('.slide-before-checkbox');
    const afterCheckbox = activeRow.querySelector('.slide-after-checkbox');
    const currentType = typeCell.textContent.trim();
    
    const previousRow = activeRow.previousElementSibling;
    const previousType = previousRow ? previousRow.querySelector('.item-type').textContent.trim() : null;
    
    beforeCheckbox.checked = !(previousType && previousType.toLowerCase() === currentType.toLowerCase());
    
    detailCell.textContent = selectedSong.name;
    turlsCell.textContent = '[]';
    
    showToast(`Copying ${selectedSong.name} into your service plan`, 8);
    
    const result = await copySongToServicePlan(selectedSong.id, selectedPlanId, selectedSong.name);
    
    if (result.success) {
      typeCell.classList.add('song-link');
      typeCell.dataset.id = result.fileId;
      
      updateUploadButton(activeRow, true);
      enableEditButton(activeRow);
      beforeCheckbox.disabled = false;
      afterCheckbox.disabled = false;
      beforeCheckbox.style.visibility = 'visible';
      afterCheckbox.style.visibility = 'visible';
      
      if (result.thumbnailUrls) {
        slidesCell.textContent = result.thumbnailUrls.length;
        turlsCell.textContent = JSON.stringify(result.thumbnailUrls);
        refreshGallery();
      }
      
      triggerAutoSave();
    }
    
    resetSongModal();
    
  } catch (error) {
    handleError(error);
  }
}



async function refreshGallery() {
 //debugLog("Refreshing gallery");
  
  // Clear the gallery
  const gallery = document.getElementById('slidesGallery');
  gallery.innerHTML = '';
  
  let slideNumber = 1; // Keep track of overall slide numbers
  
  // Process all rows in the service items table
  const rows = document.querySelectorAll('#serviceItemsTable tbody tr');
  
  for (const row of rows) {
    const beforeCheckbox = row.querySelector('.slide-before-checkbox');
    const afterCheckbox = row.querySelector('.slide-after-checkbox');
    const turlsCell = row.querySelector('.item-tUrls');
    
    // Add blank slide before if checkbox is checked
    if (beforeCheckbox && beforeCheckbox.checked) {
      const div = document.createElement('div');
      div.className = 'slide-thumbnail';
      div.innerHTML = `
        <div style="height: 100%; background-color: white;"></div>
        <div class="slide-number">${slideNumber++}</div>
      `;
      gallery.appendChild(div);
    }
    
    // Add song/presentation slides if tUrls exists
    if (turlsCell && turlsCell.textContent) {
      try {
        const thumbnailUrls = JSON.parse(turlsCell.textContent);
        if (thumbnailUrls && thumbnailUrls.length > 0) {
          for (let i = 0; i < thumbnailUrls.length; i++) {
            const div = document.createElement('div');
            div.className = 'slide-thumbnail is-song';
            div.innerHTML = `
              <img src="${thumbnailUrls[i]}" alt="Slide ${slideNumber}" loading="lazy">
              <div class="slide-number">${slideNumber++}</div>
            `;
            gallery.appendChild(div);
          }
        }
      } catch (error) {
        debugLog("Error processing thumbnails: " + error);
      }
    }
    
    // Add blank slide after if checkbox is checked
    if (afterCheckbox && afterCheckbox.checked) {
      const div = document.createElement('div');
      div.className = 'slide-thumbnail';
      div.innerHTML = `
        <div style="height: 100%; background-color: white;"></div>
        <div class="slide-number">${slideNumber++}</div>
      `;
      gallery.appendChild(div);
    }
  }
  
  //debugLog(`Gallery refresh complete with ${slideNumber - 1} total slides`);
}


function displaySongModal() {
  const existingModal = bootstrap.Modal.getInstance(document.getElementById('songSelectModal'));
  if (existingModal) {
    existingModal.dispose();
  }

  const modal = new bootstrap.Modal(document.getElementById('songSelectModal'));
  const searchBox = document.getElementById('songSearch');
  
  // Reset to name search
  const nameSearchRadio = document.getElementById('nameSearch');
  nameSearchRadio.checked = true;
  
  // Trigger change event to update UI
  nameSearchRadio.dispatchEvent(new Event('change'));
  
  // Initialize search functionality
  initializeSongSearch();
  
  // Get the current item type
  const itemType = activeRow.querySelector('.item-type').textContent.trim();
  
  // If type is Creed, pre-fill search with "Creed"
  if (itemType.toLowerCase() === 'creed') {
    searchBox.value = "Creed";
    filterSongList("Creed");
  } else {
    // For songs, use existing detail text
    const detailText = activeRow.querySelector('.item-detail').textContent.trim();
    searchBox.value = detailText;
    if (detailText) {
      filterSongList(detailText);
    } else {
      displaySongList(songListData);
    }
  }
  
  // Enable/disable API search options based on global settings

  
  const hasAPISettings = !!settings.apiKey;
  document.getElementById('bibleSearch').disabled = !hasAPISettings;
  document.getElementById('themeSearch').disabled = !hasAPISettings;
  
  modal.show();
}

function displaySongList(songs) {
  const list = document.getElementById('songSelectList');
  list.innerHTML = songs.map(song => `
    <div class="list-group-item list-group-item-action d-flex justify-content-between align-items-center"
         data-name="${song.name}"
         data-id="${song.id}">
      <span>${song.name}</span>
      <div class="preview-btn"
           onclick="event.stopPropagation(); showPreview('${song.id}', '${song.name}')"
           title="Preview song"
           role="button"
           tabindex="0">
        👀
      </div>
    </div>
  `).join('');
}

function showPreview(id, title) {
 
  const previewModal = new bootstrap.Modal(document.getElementById('previewModal'));
  const frame = document.getElementById('previewFrame');
  
  document.querySelector('#previewModal .modal-title').textContent = 'Preview: ' + title;
  frame.src = `https://docs.google.com/presentation/d/${id}/preview`;
  
  previewModal.show();
}

function resetSongModal() {
  document.getElementById('songSearch').value = '';
  document.getElementById('chooseSongBtn').disabled = true;
  selectedSong = null;
  //displaySongList(songListData); DONT THINK THIS IS NEEDED HERE
}

function resetFileModal() {
  document.getElementById('fileInput').value = '';
  document.getElementById('uploadStatus').style.display = 'none';
}

function showUploadStatus(message, type) {
  const status = document.getElementById('uploadStatus');
  status.textContent = message;
  status.className = 'alert alert-' + type;
  status.style.display = 'block';
}

function showLoading(show, message = 'Loading...') {
  const overlay = document.getElementById('loadingOverlay');
  const loadingText = overlay.querySelector('#loadingMessage');
  const loadingProgress = overlay.querySelector('#loadingProgress');
  
  if (show) {
    loadingText.textContent = message;
    loadingProgress.textContent = '';
    overlay.style.display = 'grid';
  } else {
    overlay.style.display = 'none';
  }
}

async function loadServicePlans() {
  debugLog("Loading service plans");
  showLoading(true, 'Loading service plans...');
  await getServicePlans()
    .then(result => {
      plans = result;
      })
    .catch(error => {
        alert('Error:' + error);
       }); 

  debugLog(`Loaded ${plans.length} plans`);
  displayPlans(plans);
  showLoading(false);
}


async function loadSongs() {
  if (songsLoaded) {return};
  debugLog("Loading songs from drive");
 
  await getSongList()
    .then(result => {
      songs = result;
    })
    .catch(error => {
      alert('Error:' + error);
    }); 

  songListData = songs.map(song => ({
    name: song.name,
    id: song.id,
    sanitizedName: song.name.replace(/\[.*\]$/, '').replace(/,/g, '').trim()
  }))
  .sort((a, b) => a.name.localeCompare(b.name));

  debugLog("Successfully loaded " + songListData.length + " songs");
  songsLoaded = true;
}

function insertNewLine(row) {
  const tbody = row.closest('tbody');
  const rows = Array.from(tbody.querySelectorAll('tr'));
  const rowIndex = rows.indexOf(row);
  
  const newRow = document.createElement('tr');
  newRow.innerHTML = `
        <td class="item-number grab-icon" draggable="true"></td>
        <td class="item-type" contenteditable="true"></td>
        <td class="item-detail" contenteditable="true"></td>
        <td>
            <input type="checkbox" class="slide-before-checkbox" title="Add blank slide before">
        </td>
        <td>
            <input type="checkbox" class="slide-after-checkbox" title="Add blank slide after">
        </td>
        <td class="item-slides"></td>
        <td class="item-tUrls"></td>
        <td>
          <button class="btn btn-sm upload-btn">
            <span>↑</span>
          </button>
        </td>
        <td>
          <button class="btn btn-sm delete-btn">
              <span>🗑</span>
          </button>
        </td>
        <td>
            <button class="btn btn-sm edit-btn">
                <span>✎</span>
            </button>
        </td>
    `;
  
  if (row.nextSibling) {
    tbody.insertBefore(newRow, row.nextSibling);
  } else {
    tbody.appendChild(newRow);
  }
  
  reorderItemNumbers();
  reapplyAlternatingColors();
}

function setupDeleteHandlers() {
  document.querySelector('#serviceItemsTable').addEventListener('click', function(e) {
    const deleteBtn = e.target.closest('.delete-btn');
    if (deleteBtn) {
      const row = deleteBtn.closest('tr');
      const type = row.querySelector('.item-type').textContent.trim();
      const detail = row.querySelector('.item-detail').textContent.trim();
      
      // Skip confirmation if row is empty
      const isEmpty = !type && !detail;
      
      if (isEmpty) {
        deleteRow(row);
      } else {
        showConfirmModal({
          title: 'Delete Item',
          message: 'Are you sure you want to delete this item?',
          buttonText: 'Delete',
          buttonClass: 'btn-danger',
          onConfirm: () => {
            deleteRow(row);
          }
        });
      }
    }
  });
}

// Helper function to handle row deletion
function deleteRow(row) {
  row.remove();
  refreshGallery();
  triggerAutoSave();
  
  // Update row numbers and alternating colors
  const tbody = document.querySelector('#serviceItemsTable tbody');
  const remainingRows = tbody.querySelectorAll('tr');
  remainingRows.forEach((row, index) => {
    row.querySelector('.item-number').textContent = index + 1;
    row.className = index % 2 === 0 ? '' : 'table-light';
  });
}

async function populateServiceItems(items) {
  const tbody = document.querySelector('#serviceItemsTable tbody');
  tbody.innerHTML = '';
  
  // Clear the gallery
  const gallery = document.getElementById('slidesGallery');
  gallery.innerHTML = '';
  
  // Calculate needed rows (minimum 12)
  const numRows = Math.max(12, items ? items.length : 0);
  
  // Create all rows first
  for (let i = 1; i <= numRows; i++) {
    const row = document.createElement('tr');
    row.className = i % 2 === 0 ? 'table-light' : '';
    row.innerHTML = `
        <td class="item-number grab-icon" draggable="true">${i}</td>
        <td class="item-type" contenteditable="true"></td>
        <td class="item-detail" contenteditable="true"></td>
        <td>
            <input type="checkbox" class="slide-before-checkbox" title="Add blank slide before">
        </td>
        <td>
            <input type="checkbox" class="slide-after-checkbox" title="Add blank slide after">
        </td>
        <td class="item-slides"></td>
        <td class="item-tUrls"></td>
        <td>
          <button class="btn btn-sm upload-btn" disabled style="opacity: 0.5">
            <span>↑</span>
          </button>
        </td>
        <td>
        <button class="btn btn-sm delete-btn">
            <span>🗑</span>
        </button>
        </td>
        <td>
           <button class="btn btn-sm edit-btn">
              <span>✎</span>
           </button>
        </td>
    `;
    tbody.appendChild(row);
  }
  
  // If we have items to populate
  if (items && items.length > 0) {
    for (const [index, item] of items.entries()) {
      const row = tbody.children[index];
      const typeCell = row.querySelector('.item-type');
      const detailCell = row.querySelector('.item-detail');
      const slidesCell = row.querySelector('.item-slides');
      const turlsCell = row.querySelector('.item-tUrls');
      const uploadBtn = row.querySelector('.upload-btn');
      const beforeCheckbox = row.querySelector('.slide-before-checkbox');
      const afterCheckbox = row.querySelector('.slide-after-checkbox');
      
      if (beforeCheckbox) beforeCheckbox.checked = item.blankBefore || false;
      if (afterCheckbox) afterCheckbox.checked = item.blankAfter || false;
      
      typeCell.textContent = item.type || '';
      detailCell.textContent = item.detail || '';
      slidesCell.textContent = item.slides || '';
      
      // Set tUrls if they exist in the item
      if (item.tUrls && Array.isArray(item.tUrls)) {
        turlsCell.textContent = JSON.stringify(item.tUrls);
      } else {
        turlsCell.textContent = '[]';
      }
      
      // Enable upload button if item type exists
      if (typeCell.textContent.trim()) {
        enableUploadButton(row);
      } else {
        disableUploadButton(row);
      }
      
      // Add link data if it exists and handle checkboxes
      if (item.slides) {
        refreshGallery();
      }
    
      if (item.link) {
        typeCell.dataset.id = item.link;
        typeCell.classList.add('song-link');
        enableEditButton(row);
        
        // Always enable and show checkboxes when there's a link to slides
        beforeCheckbox.disabled = false;
        afterCheckbox.disabled = false;
        beforeCheckbox.style.visibility = 'visible';
        afterCheckbox.style.visibility = 'visible';
        
        // For songs and similar items, hide the upload button
        const validTypes = ['song', 'creed', 'sing', 'hymn']; 
        if (validTypes.includes(item.type.toLowerCase())) {
          uploadBtn.style.visibility = 'hidden';
          uploadBtn.disabled = true;
        }
      } else {
        // Disable and hide checkboxes for items without links
        beforeCheckbox.disabled = true;
        afterCheckbox.disabled = true;
        beforeCheckbox.style.visibility = 'hidden';
        afterCheckbox.style.visibility = 'hidden';
        // Reset checkbox states
        beforeCheckbox.checked = false;
        afterCheckbox.checked = false;
      }
    }
  }
}

function reorderItemNumbers() {
  //debugLog("Reordering item numbers");
  const rows = document.querySelectorAll('#serviceItemsTable tbody tr');
  rows.forEach((row, index) => {
    const itemNumberCell = row.querySelector('.item-number');
    if (itemNumberCell) {
      itemNumberCell.textContent = index + 1;
    }
  });
}

function reapplyAlternatingColors() {
  //debugLog("Reapplying alternating colors");
  const rows = document.querySelectorAll('#serviceItemsTable tbody tr');
  rows.forEach((row, index) => {
    row.classList.remove('table-light');
    if (index % 2 === 1) {
      row.classList.add('table-light');
    }
  });
}

function triggerAutoSave() {

  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    saveServiceOrder();
  }, 5000);
}

// Add new function to manage upload button visibility
function updateUploadButton(row, shouldDisable) {
  const uploadBtn = row.querySelector('.upload-btn');
  if (uploadBtn) {
    if (shouldDisable) {
      uploadBtn.style.visibility = 'hidden';
      uploadBtn.disabled = true;
    } else {
      uploadBtn.style.visibility = 'visible';
      uploadBtn.disabled = false;
    }
  }
}

function initializeUploadButtons() {
  const tbody = document.querySelector('#serviceItemsTable tbody');
  const rows = tbody.querySelectorAll('tr');
  
  rows.forEach(row => {
    const uploadBtn = row.querySelector('.upload-btn');
    const typeCell = row.querySelector('.item-type');
    
    // Initially disable upload button
    if (uploadBtn) {
      console.log("UPBUTTON DISABLED");
      uploadBtn.disabled = true;
      uploadBtn.style.opacity = '0.5';
    }
    
    // Check initial state
    if (typeCell && typeCell.textContent.trim()) {
      console.log("UPBUTTON ENABLED");
      enableUploadButton(row);
    }
  });
}

// Add this function to enable/disable upload button
function enableUploadButton(row) {
  console.log(`BUTTON ENABLED ON ROW`);
  const uploadBtn = row.querySelector('.upload-btn');
  if (uploadBtn) {
    uploadBtn.disabled = false;
    uploadBtn.style.opacity = '1';
  }
}

function disableUploadButton(row) {
  const uploadBtn = row.querySelector('.upload-btn');
  if (uploadBtn) {
    uploadBtn.disabled = true;
    uploadBtn.style.opacity = '0.5';
  }
}
function initializeEditButtons() {
  const tbody = document.querySelector('#serviceItemsTable tbody');
  const rows = tbody.querySelectorAll('tr');
  
  rows.forEach(row => {
    const editBtn = row.querySelector('.edit-btn');
    const typeCell = row.querySelector('.item-type');
    
    // Initially disable edit button
    if (editBtn) {
      editBtn.disabled = true;
      editBtn.style.opacity = '0.5';
    }
    
    // Check initial state
    if (typeCell && typeCell.dataset.id) {
      enableEditButton(row);
    }
  });
}

function setupEditHandlers() {
  document.querySelector('#serviceItemsTable').addEventListener('click', async function(e) {
    const editBtn = e.target.closest('.edit-btn');
    if (editBtn && !editBtn.disabled) {
      const row = editBtn.closest('tr');
      const typeCell = row.querySelector('.item-type');
      const fileId = typeCell.dataset.id;
      
      if (fileId) {
        let editUrl = "https://docs.google.com/presentation/d/" + fileId + "/edit?usp=sharing";
        activeRow = row;
        handleSlideEdit(editUrl, fileId);
      }
    }
  });
}

function enableEditButton(row) {
  const editBtn = row.querySelector('.edit-btn');
  if (editBtn) {
    editBtn.disabled = false;
    editBtn.style.opacity = '1';
  }
}

function disableEditButton(row) {
  const editBtn = row.querySelector('.edit-btn');
  if (editBtn) {
    editBtn.disabled = true;
    editBtn.style.opacity = '0.5';
  }
}

function handleSlideEdit(editUrl, fileId) {
  // First attempt to open the window
  const editWindow = window.open(editUrl, '_blank');
  debugLog(`Edit entered for ${editUrl}`);
  
  // Check if popup was blocked
  if (!editWindow || editWindow.closed || typeof editWindow.closed === 'undefined') {
    // Create a clickable link if popup was blocked
    const overlay = document.createElement('div');
    overlay.id = 'popupBlockedOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 9999;
      text-align: center;
    `;
    overlay.innerHTML = `
      <h4>Popup Blocked</h4>
      <p>Your browser blocked the slides editor window.</p>
      <p>Click the button below to open the editor:</p>
      <button class="btn btn-primary" id="openEditorBtn">Open Slides Editor</button>
    `;
    document.body.appendChild(overlay);
    
    // Add click handler for the button
    document.getElementById('openEditorBtn').onclick = function() {
      overlay.remove();
      window.open(editUrl, '_blank');
      setupEditingOverlay(fileId);
    };
    return;
  }
  
  // Set up the editing overlay
  setupEditingOverlay(fileId);
  
  // Set up an interval to check if the edit window is closed
  const checkWindow = setInterval(async () => {
    if (editWindow.closed) {
      clearInterval(checkWindow);
      
      // Clean up the editing state
      cleanupEditingState();
      
      // Get new thumbnails and refresh gallery
      if (activeRow) {
        const slidesCell = activeRow.querySelector('.item-slides');
        const turlsCell = activeRow.querySelector('.item-tUrls');
     
        await getThumbnailUrls(fileId)
          .then(result => {
            thumbnailUrls = result;
          })
          .catch(error => {
            throw error(error);
          }); 
          
        if (thumbnailUrls) {
          slidesCell.textContent = thumbnailUrls.length;
          turlsCell.textContent = JSON.stringify(thumbnailUrls);
          refreshGallery();
          triggerAutoSave();
        }
      }
    }
  }, 1000);
}

async function getSettings() {
  await callGetSettings()
    .then(result => {
      settings = result;
       const titleElement = document.querySelector('.service-planner-title'); 
       if (titleElement && settings.Title) {
        titleElement.textContent = settings.Title;
       }
       // Set license text if present in settings
       const licenseElement = document.querySelector('#licenseText small');
       if (licenseElement && settings.Licence) {
        licenseElement.textContent = settings.Licence;
       }
    })
    .catch(error => {
        alert('Get Settings Error:' + error);
       }); 
}



</script>